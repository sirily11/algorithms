{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"algorithms \u00b6 algorithms written in python Notebooks are included inside the notebooks/ folder.","title":"algorithms"},{"location":"#algorithms","text":"algorithms written in python Notebooks are included inside the notebooks/ folder.","title":"algorithms"},{"location":"algorithms/sort/insertion_sort/","text":"Insertion sort \u00b6 Time Complexity : \\(O(n^2)\\) Auxiliary Space : \\(O(1)\\) Boundary Cases : Insertion sort takes maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted. def insertion_sort ( arr ): for i in range ( 1 , len ( arr )): key = arr [ i ] j = i - 1 while j >= 0 and key < arr [ j ] : arr [ j + 1 ] = arr [ j ] j -= 1 arr [ j + 1 ] = key return arr insertion_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Insertion sort"},{"location":"algorithms/sort/insertion_sort/#insertion-sort","text":"Time Complexity : \\(O(n^2)\\) Auxiliary Space : \\(O(1)\\) Boundary Cases : Insertion sort takes maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted. def insertion_sort ( arr ): for i in range ( 1 , len ( arr )): key = arr [ i ] j = i - 1 while j >= 0 and key < arr [ j ] : arr [ j + 1 ] = arr [ j ] j -= 1 arr [ j + 1 ] = key return arr insertion_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Insertion sort"},{"location":"algorithms/sort/merge_sort/","text":"Merge sort \u00b6 Time Complexity : \\(O(nlog(n))\\) Auxiliary Space : \\(O(n)\\) def merge_sort ( arr ): if len ( arr ) > 1 : mid = len ( arr ) // 2 # Finding the mid of the array l = arr [: mid ] # Dividing the array elements r = arr [ mid :] # into 2 halves merge_sort ( l ) # Sorting the first half merge_sort ( r ) # Sorting the second half i = j = k = 0 while i < len ( l ) and j < len ( r ): if l [ i ] < r [ j ]: arr [ k ] = l [ i ] i += 1 else : arr [ k ] = r [ j ] j += 1 k += 1 while i < len ( l ): arr [ k ] = l [ i ] i += 1 k += 1 while j < len ( r ): arr [ k ] = r [ j ] j += 1 k += 1 return arr merge_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Merge sort"},{"location":"algorithms/sort/merge_sort/#merge-sort","text":"Time Complexity : \\(O(nlog(n))\\) Auxiliary Space : \\(O(n)\\) def merge_sort ( arr ): if len ( arr ) > 1 : mid = len ( arr ) // 2 # Finding the mid of the array l = arr [: mid ] # Dividing the array elements r = arr [ mid :] # into 2 halves merge_sort ( l ) # Sorting the first half merge_sort ( r ) # Sorting the second half i = j = k = 0 while i < len ( l ) and j < len ( r ): if l [ i ] < r [ j ]: arr [ k ] = l [ i ] i += 1 else : arr [ k ] = r [ j ] j += 1 k += 1 while i < len ( l ): arr [ k ] = l [ i ] i += 1 k += 1 while j < len ( r ): arr [ k ] = r [ j ] j += 1 k += 1 return arr merge_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Merge sort"},{"location":"algorithms/sort/selection_sort/","text":"Selection sort \u00b6 Time Complexity : \\(O(n^2)\\) as there are two nested loops. Auxiliary Space : \\(O(1)\\) def selection_sort ( arr ): new_arr = arr for i in range ( len ( new_arr )): min_index = i for j in range ( i + 1 , len ( new_arr )): if new_arr [ j ] < new_arr [ min_index ]: min_index = j new_arr [ i ], new_arr [ min_index ] = new_arr [ min_index ], new_arr [ i ] return new_arr print ( selection_sort ([ 4 , 5 , 1 , 3 , 2 ])) [1, 2, 3, 4, 5]","title":"Selection sort"},{"location":"algorithms/sort/selection_sort/#selection-sort","text":"Time Complexity : \\(O(n^2)\\) as there are two nested loops. Auxiliary Space : \\(O(1)\\) def selection_sort ( arr ): new_arr = arr for i in range ( len ( new_arr )): min_index = i for j in range ( i + 1 , len ( new_arr )): if new_arr [ j ] < new_arr [ min_index ]: min_index = j new_arr [ i ], new_arr [ min_index ] = new_arr [ min_index ], new_arr [ i ] return new_arr print ( selection_sort ([ 4 , 5 , 1 , 3 , 2 ])) [1, 2, 3, 4, 5]","title":"Selection sort"},{"location":"problems/add_two_numbers/","text":"Add two numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1 \u00b6 Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. class ListNode : def __init__ ( self , val = 0 , next = None ): self . val = val self . next : ListNode = next def print ( self ): print ( self . val ) if self . next : self . next . print () def add_two_numbers ( l1 : ListNode , l2 : ListNode , c = 0 ) -> ListNode : val = l1 . val + l2 . val + c c = val // 10 ret = ListNode ( val % 10 ) if l1 . next or l2 . next or c > 0 : if not l1 . next : l1 . next = ListNode ( 0 ) if not l2 . next : l2 . next = ListNode ( 0 ) ret . next = add_two_numbers ( l1 . next , l2 . next , c ) return ret Create list \u00b6 node1 = ListNode ( 2 ) node1 . next = ListNode ( 4 ) node1 . next . next = ListNode ( 3 ) node2 = ListNode ( 5 ) node2 . next = ListNode ( 6 ) node2 . next . next = ListNode ( 4 ) print ( \"Node 1\" ) node1 . print () print ( \"Node 2\" ) node2 . print () Node 1 2 4 3 Node 2 5 6 4 Result \u00b6 result = add_two_numbers ( node1 , node2 ) result . print () 7 0 8 Time: \\(O(n)\\) \u00b6","title":"Add two numbers"},{"location":"problems/add_two_numbers/#example-1","text":"Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. class ListNode : def __init__ ( self , val = 0 , next = None ): self . val = val self . next : ListNode = next def print ( self ): print ( self . val ) if self . next : self . next . print () def add_two_numbers ( l1 : ListNode , l2 : ListNode , c = 0 ) -> ListNode : val = l1 . val + l2 . val + c c = val // 10 ret = ListNode ( val % 10 ) if l1 . next or l2 . next or c > 0 : if not l1 . next : l1 . next = ListNode ( 0 ) if not l2 . next : l2 . next = ListNode ( 0 ) ret . next = add_two_numbers ( l1 . next , l2 . next , c ) return ret","title":"Example 1"},{"location":"problems/add_two_numbers/#create-list","text":"node1 = ListNode ( 2 ) node1 . next = ListNode ( 4 ) node1 . next . next = ListNode ( 3 ) node2 = ListNode ( 5 ) node2 . next = ListNode ( 6 ) node2 . next . next = ListNode ( 4 ) print ( \"Node 1\" ) node1 . print () print ( \"Node 2\" ) node2 . print () Node 1 2 4 3 Node 2 5 6 4","title":"Create list"},{"location":"problems/add_two_numbers/#result","text":"result = add_two_numbers ( node1 , node2 ) result . print () 7 0 8","title":"Result"},{"location":"problems/add_two_numbers/#time-on","text":"","title":"Time: \\(O(n)\\)"},{"location":"problems/climbing_stairs/","text":"Climbing Stairs \u00b6 You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Example 1 \u00b6 Input : 2 Output : 2 Explanation : There are two ways to climb to the top . 1 . 1 step + 1 step 2 . 2 steps Example 2 \u00b6 Input : 3 Output : 3 Explanation : There are three ways to climb to the top . 1 . 1 step + 1 step + 1 step 2 . 1 step + 2 steps 3 . 2 steps + 1 step def climbing ( n : int ): if n == 0 or n == 1 : return 1 nums = [] nums . append ( 1 ) nums . append ( 1 ) for i in range ( 2 , n + 1 ): result = nums [ i - 1 ] + nums [ i - 2 ] nums . append ( result ) return nums [ - 1 ] climbing ( 4 ) 5","title":"Climbing stairs"},{"location":"problems/climbing_stairs/#climbing-stairs","text":"You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?","title":"Climbing Stairs"},{"location":"problems/climbing_stairs/#example-1","text":"Input : 2 Output : 2 Explanation : There are two ways to climb to the top . 1 . 1 step + 1 step 2 . 2 steps","title":"Example 1"},{"location":"problems/climbing_stairs/#example-2","text":"Input : 3 Output : 3 Explanation : There are three ways to climb to the top . 1 . 1 step + 1 step + 1 step 2 . 1 step + 2 steps 3 . 2 steps + 1 step def climbing ( n : int ): if n == 0 or n == 1 : return 1 nums = [] nums . append ( 1 ) nums . append ( 1 ) for i in range ( 2 , n + 1 ): result = nums [ i - 1 ] + nums [ i - 2 ] nums . append ( result ) return nums [ - 1 ] climbing ( 4 ) 5","title":"Example 2"},{"location":"problems/combine_sorted_array/","text":"Combine 2 sorted arrays \u00b6 Input: arr1: [1,2,3], arr2: [4,5,6] Output: [1,2,3,4,5,6] Solution \u00b6 def combine ( arr1 , arr2 ): i = 0 j = 0 output = [] while i < len ( arr1 ): if arr1 [ i ] < arr2 [ j ]: output . append ( arr1 [ i ]) i += 1 else : output . append ( arr2 [ j ]) j += 1 if j < len ( arr2 ): output += arr2 [ j :] return output combine ([ 1 , 2 , 3 ], [ 4 , 5 , 6 ]) [1, 2, 3, 4, 5, 6] combine ([ 1 , 5 , 8 ], [ 2 , 4 , 9 ]) [1, 2, 4, 5, 8, 9]","title":"Combine sorted array"},{"location":"problems/combine_sorted_array/#combine-2-sorted-arrays","text":"Input: arr1: [1,2,3], arr2: [4,5,6] Output: [1,2,3,4,5,6]","title":"Combine 2 sorted arrays"},{"location":"problems/combine_sorted_array/#solution","text":"def combine ( arr1 , arr2 ): i = 0 j = 0 output = [] while i < len ( arr1 ): if arr1 [ i ] < arr2 [ j ]: output . append ( arr1 [ i ]) i += 1 else : output . append ( arr2 [ j ]) j += 1 if j < len ( arr2 ): output += arr2 [ j :] return output combine ([ 1 , 2 , 3 ], [ 4 , 5 , 6 ]) [1, 2, 3, 4, 5, 6] combine ([ 1 , 5 , 8 ], [ 2 , 4 , 9 ]) [1, 2, 4, 5, 8, 9]","title":"Solution"},{"location":"problems/sum_array_equals_to_k/","text":"Subarray Sum Equals K \u00b6 Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1 \u00b6 Input : nums = [ 1 , 1 , 1 ], k = 2 Output : 2 Solution \u00b6 First let say we have a array [1, 2, 3, 4] Then we have a pre-array which contains the sum of the elements before. [1, 3, 6, 10] And we can find that the sum of sub-array [2, 3, 4] is equal to difference between 10 and 1 And now we can have a equation of sum of array from index j to index k \\( \\(\\sum_{i=j}^{k}array[i] = pre[k] - pre[j - 1] = target\\) \\) Or \\[pre[k] - target = pre[j - 1]\\] And we can first store the value \\(pre[j-1]\\) and then find if any \\(pre[k] - target\\) is equal to the value we have before. If so, then there is a sub-array with sum equals to target Else, go to next value from typing import List , Dict def find_subarray ( arr : List [ int ], target : int ) -> int : pre = 0 visited_map : Dict [ int , int ] = { 0 : 1 } count = 0 for i in range ( len ( arr )): pre += arr [ i ] # find if pre[k] - target exists if pre - target in visited_map : count += visited_map [ pre - target ] # Set the current value to the map visited_map [ pre ] = visited_map . get ( pre , 0 ) + 1 return count find_subarray ([ 1 , 1 , 1 ], 2 ) 2 find_subarray ([ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], 0 ) 55","title":"Sum array equals to k"},{"location":"problems/sum_array_equals_to_k/#subarray-sum-equals-k","text":"Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.","title":"Subarray Sum Equals K"},{"location":"problems/sum_array_equals_to_k/#example-1","text":"Input : nums = [ 1 , 1 , 1 ], k = 2 Output : 2","title":"Example 1"},{"location":"problems/sum_array_equals_to_k/#solution","text":"First let say we have a array [1, 2, 3, 4] Then we have a pre-array which contains the sum of the elements before. [1, 3, 6, 10] And we can find that the sum of sub-array [2, 3, 4] is equal to difference between 10 and 1 And now we can have a equation of sum of array from index j to index k \\( \\(\\sum_{i=j}^{k}array[i] = pre[k] - pre[j - 1] = target\\) \\) Or \\[pre[k] - target = pre[j - 1]\\] And we can first store the value \\(pre[j-1]\\) and then find if any \\(pre[k] - target\\) is equal to the value we have before. If so, then there is a sub-array with sum equals to target Else, go to next value from typing import List , Dict def find_subarray ( arr : List [ int ], target : int ) -> int : pre = 0 visited_map : Dict [ int , int ] = { 0 : 1 } count = 0 for i in range ( len ( arr )): pre += arr [ i ] # find if pre[k] - target exists if pre - target in visited_map : count += visited_map [ pre - target ] # Set the current value to the map visited_map [ pre ] = visited_map . get ( pre , 0 ) + 1 return count find_subarray ([ 1 , 1 , 1 ], 2 ) 2 find_subarray ([ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], 0 ) 55","title":"Solution"},{"location":"problems/two_sums%20II/","text":"Two sum II \u00b6 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example 1 \u00b6 Input : numbers = [ 2 , 7 , 11 , 15 ], target = 9 Output : [ 1 , 2 ] Explanation : The sum of 2 and 7 is 9 . Therefore index1 = 1 , index2 = 2 . Example 2 \u00b6 Input : numbers = [ 2 , 3 , 4 ], target = 6 Output : [ 1 , 3 ] Solution \u00b6 from typing import List def two_sum ( nums : List [ int ], target : int ) -> List [ int ]: left = 0 right = len ( nums ) - 1 while left < right : total = nums [ left ] + nums [ right ] if total < target : left += 1 elif total > target : right -= 1 else : return [ left + 1 , right + 1 ] two_sum ([ 2 , 3 , 4 ], 6 ) [1, 3] Time: \\(O(n)\\) \u00b6","title":"Two sums ii"},{"location":"problems/two_sums%20II/#two-sum-ii","text":"Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice.","title":"Two sum II"},{"location":"problems/two_sums%20II/#example-1","text":"Input : numbers = [ 2 , 7 , 11 , 15 ], target = 9 Output : [ 1 , 2 ] Explanation : The sum of 2 and 7 is 9 . Therefore index1 = 1 , index2 = 2 .","title":"Example 1"},{"location":"problems/two_sums%20II/#example-2","text":"Input : numbers = [ 2 , 3 , 4 ], target = 6 Output : [ 1 , 3 ]","title":"Example 2"},{"location":"problems/two_sums%20II/#solution","text":"from typing import List def two_sum ( nums : List [ int ], target : int ) -> List [ int ]: left = 0 right = len ( nums ) - 1 while left < right : total = nums [ left ] + nums [ right ] if total < target : left += 1 elif total > target : right -= 1 else : return [ left + 1 , right + 1 ] two_sum ([ 2 , 3 , 4 ], 6 ) [1, 3]","title":"Solution"},{"location":"problems/two_sums%20II/#time-on","text":"","title":"Time: \\(O(n)\\)"},{"location":"problems/two_sums/","text":"Two sum \u00b6 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1 \u00b6 Input : nums = [ 2 , 7 , 11 , 15 ], target = 9 Output : [ 0 , 1 ] Output : Because nums [ 0 ] + nums [ 1 ] == 9 , we return [ 0 , 1 ]. Example 2 \u00b6 Input : nums = [ 3 , 2 , 4 ], target = 6 Output : [ 1 , 2 ] Solution \u00b6 from typing import List def two_sum ( nums : List [ int ], target : int ) -> List [ int ]: length = len ( nums ) for i in range ( length - 1 ): for j in range ( i + 1 , length ): if nums [ i ] + nums [ j ] == target : return [ i , j ] return [] two_sum ([ 3 , 2 , 4 ], 6 ) [1, 2]","title":"Two sums"},{"location":"problems/two_sums/#two-sum","text":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.","title":"Two sum"},{"location":"problems/two_sums/#example-1","text":"Input : nums = [ 2 , 7 , 11 , 15 ], target = 9 Output : [ 0 , 1 ] Output : Because nums [ 0 ] + nums [ 1 ] == 9 , we return [ 0 , 1 ].","title":"Example 1"},{"location":"problems/two_sums/#example-2","text":"Input : nums = [ 3 , 2 , 4 ], target = 6 Output : [ 1 , 2 ]","title":"Example 2"},{"location":"problems/two_sums/#solution","text":"from typing import List def two_sum ( nums : List [ int ], target : int ) -> List [ int ]: length = len ( nums ) for i in range ( length - 1 ): for j in range ( i + 1 , length ): if nums [ i ] + nums [ j ] == target : return [ i , j ] return [] two_sum ([ 3 , 2 , 4 ], 6 ) [1, 2]","title":"Solution"},{"location":"problems/sub_array/longest_substring_without_repeat/","text":"Given a string s, find the length of the longest substring without repeating characters. Example 1 \u00b6 Input : s = \"abcabcbb\" Output : 3 Explanation : The answer is \"abc\" , with the length of 3 . Example 2 \u00b6 Input : s = \"bbbbb\" Output : 1 Explanation : The answer is \"b\" , with the length of 1 . def lengthOfLongestSubstring ( s : str ) -> int : maximum_substr = \"\"","title":"Longest substring without repeat"},{"location":"problems/sub_array/longest_substring_without_repeat/#example-1","text":"Input : s = \"abcabcbb\" Output : 3 Explanation : The answer is \"abc\" , with the length of 3 .","title":"Example 1"},{"location":"problems/sub_array/longest_substring_without_repeat/#example-2","text":"Input : s = \"bbbbb\" Output : 1 Explanation : The answer is \"b\" , with the length of 1 . def lengthOfLongestSubstring ( s : str ) -> int : maximum_substr = \"\"","title":"Example 2"}]}