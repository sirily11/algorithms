{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"algorithms \u00b6 algorithms written in python Notebooks are included inside the notebooks/ folder.","title":"algorithms"},{"location":"#algorithms","text":"algorithms written in python Notebooks are included inside the notebooks/ folder.","title":"algorithms"},{"location":"algorithms/sort/insertion_sort/","text":"Insertion sort \u00b6 Time Complexity : \\(O(n^2)\\) Auxiliary Space : \\(O(1)\\) Boundary Cases : Insertion sort takes maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted. def insertion_sort ( arr ): for i in range ( 1 , len ( arr )): key = arr [ i ] j = i - 1 while j >= 0 and key < arr [ j ] : arr [ j + 1 ] = arr [ j ] j -= 1 arr [ j + 1 ] = key return arr insertion_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Insertion sort"},{"location":"algorithms/sort/insertion_sort/#insertion-sort","text":"Time Complexity : \\(O(n^2)\\) Auxiliary Space : \\(O(1)\\) Boundary Cases : Insertion sort takes maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted. def insertion_sort ( arr ): for i in range ( 1 , len ( arr )): key = arr [ i ] j = i - 1 while j >= 0 and key < arr [ j ] : arr [ j + 1 ] = arr [ j ] j -= 1 arr [ j + 1 ] = key return arr insertion_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Insertion sort"},{"location":"algorithms/sort/merge_sort/","text":"Merge sort \u00b6 Time Complexity : \\(O(nlog(n))\\) Auxiliary Space : \\(O(n)\\) def merge_sort ( arr ): if len ( arr ) > 1 : mid = len ( arr ) // 2 # Finding the mid of the array l = arr [: mid ] # Dividing the array elements r = arr [ mid :] # into 2 halves merge_sort ( l ) # Sorting the first half merge_sort ( r ) # Sorting the second half i = j = k = 0 while i < len ( l ) and j < len ( r ): if l [ i ] < r [ j ]: arr [ k ] = l [ i ] i += 1 else : arr [ k ] = r [ j ] j += 1 k += 1 while i < len ( l ): arr [ k ] = l [ i ] i += 1 k += 1 while j < len ( r ): arr [ k ] = r [ j ] j += 1 k += 1 return arr merge_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Merge sort"},{"location":"algorithms/sort/merge_sort/#merge-sort","text":"Time Complexity : \\(O(nlog(n))\\) Auxiliary Space : \\(O(n)\\) def merge_sort ( arr ): if len ( arr ) > 1 : mid = len ( arr ) // 2 # Finding the mid of the array l = arr [: mid ] # Dividing the array elements r = arr [ mid :] # into 2 halves merge_sort ( l ) # Sorting the first half merge_sort ( r ) # Sorting the second half i = j = k = 0 while i < len ( l ) and j < len ( r ): if l [ i ] < r [ j ]: arr [ k ] = l [ i ] i += 1 else : arr [ k ] = r [ j ] j += 1 k += 1 while i < len ( l ): arr [ k ] = l [ i ] i += 1 k += 1 while j < len ( r ): arr [ k ] = r [ j ] j += 1 k += 1 return arr merge_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Merge sort"},{"location":"algorithms/sort/selection_sort/","text":"Selection sort \u00b6 Time Complexity : \\(O(n^2)\\) as there are two nested loops. Auxiliary Space : \\(O(1)\\) def selection_sort ( arr ): new_arr = arr for i in range ( len ( new_arr )): min_index = i for j in range ( i + 1 , len ( new_arr )): if new_arr [ j ] < new_arr [ min_index ]: min_index = j new_arr [ i ], new_arr [ min_index ] = new_arr [ min_index ], new_arr [ i ] return new_arr print ( selection_sort ([ 4 , 5 , 1 , 3 , 2 ])) [1, 2, 3, 4, 5]","title":"Selection sort"},{"location":"algorithms/sort/selection_sort/#selection-sort","text":"Time Complexity : \\(O(n^2)\\) as there are two nested loops. Auxiliary Space : \\(O(1)\\) def selection_sort ( arr ): new_arr = arr for i in range ( len ( new_arr )): min_index = i for j in range ( i + 1 , len ( new_arr )): if new_arr [ j ] < new_arr [ min_index ]: min_index = j new_arr [ i ], new_arr [ min_index ] = new_arr [ min_index ], new_arr [ i ] return new_arr print ( selection_sort ([ 4 , 5 , 1 , 3 , 2 ])) [1, 2, 3, 4, 5]","title":"Selection sort"},{"location":"problems/combine_sorted_array/","text":"Combine 2 sorted arrays \u00b6 Input: arr1: [1,2,3], arr2: [4,5,6] Output: [1,2,3,4,5,6] Solution \u00b6 def combine ( arr1 , arr2 ): i = 0 j = 0 output = [] while i < len ( arr1 ): if arr1 [ i ] < arr2 [ j ]: output . append ( arr1 [ i ]) i += 1 else : output . append ( arr2 [ j ]) j += 1 if j < len ( arr2 ): output += arr2 [ j :] return output combine ([ 1 , 2 , 3 ], [ 4 , 5 , 6 ]) [1, 2, 3, 4, 5, 6] combine ([ 1 , 5 , 8 ], [ 2 , 4 , 9 ]) [1, 2, 4, 5, 8, 9]","title":"Combine sorted array"},{"location":"problems/combine_sorted_array/#combine-2-sorted-arrays","text":"Input: arr1: [1,2,3], arr2: [4,5,6] Output: [1,2,3,4,5,6]","title":"Combine 2 sorted arrays"},{"location":"problems/combine_sorted_array/#solution","text":"def combine ( arr1 , arr2 ): i = 0 j = 0 output = [] while i < len ( arr1 ): if arr1 [ i ] < arr2 [ j ]: output . append ( arr1 [ i ]) i += 1 else : output . append ( arr2 [ j ]) j += 1 if j < len ( arr2 ): output += arr2 [ j :] return output combine ([ 1 , 2 , 3 ], [ 4 , 5 , 6 ]) [1, 2, 3, 4, 5, 6] combine ([ 1 , 5 , 8 ], [ 2 , 4 , 9 ]) [1, 2, 4, 5, 8, 9]","title":"Solution"},{"location":"problems/two_sums%20II/","text":"Two sum II \u00b6 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example 1 \u00b6 Input : numbers = [ 2 , 7 , 11 , 15 ], target = 9 Output : [ 1 , 2 ] Explanation : The sum of 2 and 7 is 9 . Therefore index1 = 1 , index2 = 2 . Example 2 \u00b6 Input : numbers = [ 2 , 3 , 4 ], target = 6 Output : [ 1 , 3 ] Solution \u00b6 from typing import List def two_sum ( nums : List [ int ], target : int ) -> List [ int ]: left = 0 right = len ( nums ) - 1 while left < right : total = nums [ left ] + nums [ right ] if total < target : left += 1 elif total > target : right -= 1 else : return [ left + 1 , right + 1 ] two_sum ([ 2 , 3 , 4 ], 6 ) [1, 3] Time: \\(O(n)\\) \u00b6","title":"Two sums ii"},{"location":"problems/two_sums%20II/#two-sum-ii","text":"Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice.","title":"Two sum II"},{"location":"problems/two_sums%20II/#example-1","text":"Input : numbers = [ 2 , 7 , 11 , 15 ], target = 9 Output : [ 1 , 2 ] Explanation : The sum of 2 and 7 is 9 . Therefore index1 = 1 , index2 = 2 .","title":"Example 1"},{"location":"problems/two_sums%20II/#example-2","text":"Input : numbers = [ 2 , 3 , 4 ], target = 6 Output : [ 1 , 3 ]","title":"Example 2"},{"location":"problems/two_sums%20II/#solution","text":"from typing import List def two_sum ( nums : List [ int ], target : int ) -> List [ int ]: left = 0 right = len ( nums ) - 1 while left < right : total = nums [ left ] + nums [ right ] if total < target : left += 1 elif total > target : right -= 1 else : return [ left + 1 , right + 1 ] two_sum ([ 2 , 3 , 4 ], 6 ) [1, 3]","title":"Solution"},{"location":"problems/two_sums%20II/#time-on","text":"","title":"Time: \\(O(n)\\)"},{"location":"problems/two_sums/","text":"Two sum \u00b6 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1 \u00b6 Input : nums = [ 2 , 7 , 11 , 15 ], target = 9 Output : [ 0 , 1 ] Output : Because nums [ 0 ] + nums [ 1 ] == 9 , we return [ 0 , 1 ]. Example 2 \u00b6 Input : nums = [ 3 , 2 , 4 ], target = 6 Output : [ 1 , 2 ] Solution \u00b6 from typing import List def two_sum ( nums : List [ int ], target : int ) -> List [ int ]: length = len ( nums ) for i in range ( length - 1 ): for j in range ( i + 1 , length ): if nums [ i ] + nums [ j ] == target : return [ i , j ] return [] two_sum ([ 3 , 2 , 4 ], 6 ) [1, 2]","title":"Two sums"},{"location":"problems/two_sums/#two-sum","text":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.","title":"Two sum"},{"location":"problems/two_sums/#example-1","text":"Input : nums = [ 2 , 7 , 11 , 15 ], target = 9 Output : [ 0 , 1 ] Output : Because nums [ 0 ] + nums [ 1 ] == 9 , we return [ 0 , 1 ].","title":"Example 1"},{"location":"problems/two_sums/#example-2","text":"Input : nums = [ 3 , 2 , 4 ], target = 6 Output : [ 1 , 2 ]","title":"Example 2"},{"location":"problems/two_sums/#solution","text":"from typing import List def two_sum ( nums : List [ int ], target : int ) -> List [ int ]: length = len ( nums ) for i in range ( length - 1 ): for j in range ( i + 1 , length ): if nums [ i ] + nums [ j ] == target : return [ i , j ] return [] two_sum ([ 3 , 2 , 4 ], 6 ) [1, 2]","title":"Solution"}]}