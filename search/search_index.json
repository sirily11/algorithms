{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"algorithms \u00b6 algorithms written in python","title":"algorithms"},{"location":"#algorithms","text":"algorithms written in python","title":"algorithms"},{"location":"algorithms/sort/insertion_sort/","text":"Insertion sort \u00b6 Time Complexity : \\(O(n^2)\\) Auxiliary Space : \\(O(1)\\) Boundary Cases : Insertion sort takes maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted. def insertion_sort ( arr ): for i in range ( 1 , len ( arr )): key = arr [ i ] j = i - 1 while j >= 0 and key < arr [ j ] : arr [ j + 1 ] = arr [ j ] j -= 1 arr [ j + 1 ] = key return arr insertion_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Insertion sort"},{"location":"algorithms/sort/insertion_sort/#insertion-sort","text":"Time Complexity : \\(O(n^2)\\) Auxiliary Space : \\(O(1)\\) Boundary Cases : Insertion sort takes maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted. def insertion_sort ( arr ): for i in range ( 1 , len ( arr )): key = arr [ i ] j = i - 1 while j >= 0 and key < arr [ j ] : arr [ j + 1 ] = arr [ j ] j -= 1 arr [ j + 1 ] = key return arr insertion_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Insertion sort"},{"location":"algorithms/sort/merge_sort/","text":"Merge sort \u00b6 Time Complexity : \\(O(nlog(n))\\) Auxiliary Space : \\(O(n)\\) def merge_sort ( arr ): if len ( arr ) > 1 : mid = len ( arr ) // 2 # Finding the mid of the array l = arr [: mid ] # Dividing the array elements r = arr [ mid :] # into 2 halves merge_sort ( l ) # Sorting the first half merge_sort ( r ) # Sorting the second half i = j = k = 0 while i < len ( l ) and j < len ( r ): if l [ i ] < r [ j ]: arr [ k ] = l [ i ] i += 1 else : arr [ k ] = r [ j ] j += 1 k += 1 while i < len ( l ): arr [ k ] = l [ i ] i += 1 k += 1 while j < len ( r ): arr [ k ] = r [ j ] j += 1 k += 1 return arr merge_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Merge sort"},{"location":"algorithms/sort/merge_sort/#merge-sort","text":"Time Complexity : \\(O(nlog(n))\\) Auxiliary Space : \\(O(n)\\) def merge_sort ( arr ): if len ( arr ) > 1 : mid = len ( arr ) // 2 # Finding the mid of the array l = arr [: mid ] # Dividing the array elements r = arr [ mid :] # into 2 halves merge_sort ( l ) # Sorting the first half merge_sort ( r ) # Sorting the second half i = j = k = 0 while i < len ( l ) and j < len ( r ): if l [ i ] < r [ j ]: arr [ k ] = l [ i ] i += 1 else : arr [ k ] = r [ j ] j += 1 k += 1 while i < len ( l ): arr [ k ] = l [ i ] i += 1 k += 1 while j < len ( r ): arr [ k ] = r [ j ] j += 1 k += 1 return arr merge_sort ([ 4 , 3 , 2 , 1 ]) [1, 2, 3, 4]","title":"Merge sort"},{"location":"algorithms/sort/selection_sort/","text":"Selection sort \u00b6 Time Complexity : \\(O(n^2)\\) as there are two nested loops. Auxiliary Space : \\(O(1)\\) def selection_sort ( arr ): new_arr = arr for i in range ( len ( new_arr )): min_index = i for j in range ( i + 1 , len ( new_arr )): if new_arr [ j ] < new_arr [ min_index ]: min_index = j new_arr [ i ], new_arr [ min_index ] = new_arr [ min_index ], new_arr [ i ] return new_arr print ( selection_sort ([ 4 , 5 , 1 , 3 , 2 ])) [1, 2, 3, 4, 5]","title":"Selection sort"},{"location":"algorithms/sort/selection_sort/#selection-sort","text":"Time Complexity : \\(O(n^2)\\) as there are two nested loops. Auxiliary Space : \\(O(1)\\) def selection_sort ( arr ): new_arr = arr for i in range ( len ( new_arr )): min_index = i for j in range ( i + 1 , len ( new_arr )): if new_arr [ j ] < new_arr [ min_index ]: min_index = j new_arr [ i ], new_arr [ min_index ] = new_arr [ min_index ], new_arr [ i ] return new_arr print ( selection_sort ([ 4 , 5 , 1 , 3 , 2 ])) [1, 2, 3, 4, 5]","title":"Selection sort"}]}